# Assembly (Slides T2-T3)
VE370SU22 TA Runxi Wang

## Brief Intro of Assembly

high level languages (e.g. ``.cpp``) $\stackrel{compiler}{\longrightarrow}$ assembly languages (``.s``) $\stackrel{assembler}{\longrightarrow}$ machine code (``.o``) $\stackrel{linker}{\longrightarrow}$ executable machine code (``.elf``) $\stackrel{formatter}{\longrightarrow}$ machine code for a target processor (e.g. ``.exe``)

## When to Use
- Avoid uncertainties of execution time and size brought by compilers
- To speed up or reduce the size of a program
- Use with high level languages

## Shortcomings
- Can be time consuming
- No assembler optimization
- Different computers support different assemblers
- Hard to debug:(

**We will focus on RISC-V 32-bit ISA(Instruction Set Architecture) in this course!**

## Operands

### Register Operands
Register size: $32\times 32bits$ register file, from ``x0``, ``x1``, to ``x31``. 

<p align="center">
<img src="regfile.png" width=300>
</p>

How is register used?  
e.g.  
c++ code:
```c++
a = b + c;
```
Assume ``b`` is put in ``x5``, ``c`` is put in ``x6``, and ``a`` is put in ``x7``. Then the corresponding assembly is 
```assembly
add x7, x5, x6
```

### Memory Operands
**Big/Little Endian**  
Definition for big endian: Most-significant byte si at the smallest address  
e.g. A word ``0x11223344``
|Endian | 0x0fff0000 | 0x0fff0001 | 0x0fff0002 | 0x0fff0003 |    
| ------- | ---------|------------|------------|-------------- |  
|Little | 44 | 33 | 22 | 11 |  
|Big | 11 | 22 | 33 | 44 |  

**Memory Organizations**  
Array arrangement   
e.g.  
| Word Address | 0x0fff1110 | 0x0fff1114 | 0x0fff1118 | 0x0fff111C |      
|---------|---------|-------|-------|-----|       
| Array (``A``) Index | 0 | 1 | 2 | 3 |
| Data Stored in ``A`` (32bit) | 0x11111111 | 0x22222222 | 0x33333333 | 0x44444444 |   

``A[2]`` corresponds to the data stored in address ``0x0fff1118``

**Load and Store**  
e.g.  
c++ code:
```c++
A[i] = B[j];
```
Assume ``i`` is in ``x5``, ``j`` is in ``x6``, base address of array ``A`` is in ``x7``, and base address of array ``B`` is in ``x28``. Then its corresponding assembly is 
```assembly
slli x5, x5, 2
add x5, x5, x7
slli x6, x6, 2
add x6, x6, x28
lw x29, 0(x6)
sw x29, 0(x5)
```

### Immediate Operands
Involves constant data, like 0, 1, 2... or -1, -2...   
Don't need to load data from memory or register file. 

A useful constant: ``x0``. Can not be overwritten and can be used to clear a register. 

e.g. ``addi``, ``slli``...

## Get Familiar with Other Operations!

### Logical
``and``, ``or``, ``slli``...   
e.g.
```assembly
and x5, x6, x7
```
Meaning: ``x5 = x6 & x7``
```assembly
slli x5, x6, 2
```
Meaning: ``x5 = x6 << 2``

### Arithmetic
``add``, ``addi``...   
(See the examples above)

### Conditional 
``beq``, ``bne``, ``blt``, ``bge``   
e.g.  
```assembly
beq x5, x6, ELSE
add x5, x0, x0
ELSE: ...
```
Meaning: If ``x5 == x6``, neglect the code in the second line and execute the code after ``ELSE:``

### Load Upper Immediate
``lui``  
e.g.   
```assembly
lui x5, 0x11111
```
Meaning: copy ``0x11111`` to bits ``[31:12]`` of register ``x5``.

### Load/Store
``sw``, ``lw``, ``lb``, ``lbu``, ``sb``...
```assembly
lb x5, 0(x6)
```
Meaning: Load the byte stored in address ``x6`` into ``x5`` and sign extend to 32 bits. 


### Jump
``jal``, ``jalr(jr)``
```assembly
TODO
```
Meaning:

```assembly
TODO
```
Meaning:


## Reference